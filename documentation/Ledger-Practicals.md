# Ledger Practicals (0.9.0)
The Brave Ledger is a BAT-based contribution system for content users and publishers.

This document describes the details of how the [Ledger Principles](Ledger-Principles.md) are implemented.
In this version of the document,
only `ad-free` bravery is discussed.

## A Brief Summary of Anonize2 operations

There are two parts to the authorized-but-anonymous protocol:

- interacting with a _registrar_ for the purpose of creating a credential;
and,

- interacting with a _surveyor_ for the purpose of receiving a proof that allows a submission that is
known to correspond to an authorized credential,
but does not identify which credential created the submission.
However,
duplicate submissions are detected.

For the first part,
there are two steps:

- `GET /v2/registrar/{registrarType}` - returns the public key associated with a registrar;
and,

- `POST /v2/registrar/{registrarType}/{userId}` - contains a `proof` generated by the client,
and returns a corresponding `verification` from the registrar.

For the ledger there are two types of registrars:

- `persona` - used to generate a client wallet,
funded by the user's personal wallet(s),
that makes contributions to the ledger for visits to the publisher's site;
and,

- `viewing` - used to authorized multiple publisher ballots to statically report visits to an individual publisher's site.

For the second part,
there are also two steps:

- `GET /v2/surveyor/{surveyorType}/{surveyorId}/{uID}` - returns parameters associated with a surveyor allowing the client to 
construct a proof that demonstrates authorization but is anonymous;
and,

- `PUT /v2/surveyor/{surveyortype}/{surveyorId}` - contains a `proof` with a payload.

For the ledger there are two types of surveyors:

- `contribution` - used to retrieve information about the current reconciliation period;
and,

- `voting` - used to submit a ballot for a publisher.

Each contribution surveyor has one or more voting surveyors associated with it.
These allow the client to cast independent votes that are anonymous.

## Ad-free personas

### Client State
The client has various properties stored in persistent, secure storage.
In the context of this document:

- `personaId` - used to create a client wallet;

- `wallet.paymentId` - an opaque identifier for the wallet;

// FIXME
- `wallet.address` - the Ethereum address of the wallet;

- `reconcileStamp` - a timestamp indicating the end of the current period completes;

- `transactions` - an array indicating successful contributions;
and,

- `ballots` - an array indicating publisher votes waiting to be processed as authorized-but-anonymous submissions.

### How Wallets are created
When the user directs the client to create a wallet,
the client generates a new random key pair for signing, e.g.,

```
const keypair = nacl.sign.keyPair()

{
   publicKey: ...,
   secretKey: ...
}
```

Using the secretKey, the client signs the publicKey.

The client then generates a 
[version 4 UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_.28random.29)
to use as a `personaId`,
and creates a credential after making the `GET /v2/registrar/persona` request:

    <<< GET /v2/registrar/persona
    <<< content-type: application/json; charset=utf-8
    <<< accept-encoding:
    <<<
    >>> HTTP/1.1 200
    >>> cache-control: no-cache
    >>> content-type: application/json; charset=utf-8
    >>> date: Wed, 11 Jul 2016 03:51:35 GMT
    >>> vary: accept-encoding
    >>>
    >>> { "registrarVK" : "..." }

Following this is the `POST /v2/registrar/persona/{userId}` request:

    <<< POST /v2/registrar/persona/25e7eb34fe3f6b89ad9575dbf0fb3fa
    <<< content-type: application/json; charset=utf-8
    <<< accept-encoding:
    <<<
    <<< { "keychains" :
    <<<   { "user"    : 
    <<<     { "publicKey"       : "...", 
    <<<     , "signedPublicKey" : "..." 
    <<<     , "altcurrency"     : "BAT"
    <<<     }
    <<<   }
    <<<   , "proof"   : "..." 
    <<< }
    >>> HTTP/1.1 200
    >>> cache-control: no-cache
    >>> content-type: application/json; charset=utf-8
    >>> date: Wed, 11 Jul 2016 03:51:35 GMT
    >>> vary: accept-encoding
    >>>
    >>> { "wallet"       :
    >>>   { "paymentId"  : "e43bc29a-7048-486c-b75b-6c4970b4ce2a"
    >>>   , "address"    : "0xb270cFeA355cDa32ac80C30B29Cb63e96c4A26aC"
    >>>   }
    >>> , "payload"      : { "adFree" : { "fee" : { "USD" : 5 }, "days" : 30 } }
    >>> , "verification" : "..."
    >>> }

During the processing of the request,
the ledger creates an anonymous BAT card with uphold which is controlled by the
signing `secretKey`.

Note that although the ledger created the client BAT card,
it does not hold the private signing key necessary to transact using the BAT card.

After the client verifies the registrar's signature,
the client stores the `paymentId` and `address` properties in persistent, secure storage,
and generates a "recovery file" containing the `paymentId` and `secretKey`
along with instructions on how to recover funds from the client wallet.
The user is then strongly urged to print this file or upload it to an independent, secure service.

### How Reconcilation Periods are Provisioned
There are two kinds of `surveyors`: "contribution surveyors" and "voting surveyors".

When a contribution surveyor is provisioned,
it is created along with one or more associated "voting surveyors",
and these properties:

    { "currency" : "USD"
    , "amount"   : 5
    , "altcurrency" : "BAT"
    , "probi" : 845480
    , "votes"    : 5
    }

When a client makes a contribution,
the associated `PUT /v2/wallet/{paymentId}` request includes both the `surveyorId` of the contribution surveyor,
and a client-generated `viewingId` (another version 4 UUID) that --
after the contribution is processed by the ledger --
is used to create a credential authorized for one or more of the voting surveyors associated
with the contribution surveyor.
When the credential is created,
the result from the ledger includes an array of `surveyorIds` corresponding to the authorized voting surveyors for that
credential.

### How Contributions are Submitted

When the `reconcileStamp` property goes into the past,
the client may notify the user that it is time to make a contribution.

The client makes the `GET /v2/surveyor/contribution/current/{userId}` request to get information about the contribution
surveyor to be used for this contribution:

    <<< GET /v2/surveyor/contribution/current/25e7eb34fe3f6b89ad9575dbf0fb3fa
    <<< content-type: application/json; charset=utf-8
    <<< accept-encoding:
    <<<
    >>> HTTP/1.1 200
    >>> cache-control: no-cache
    >>> content-type: application/json; charset=utf-8
    >>> date: Wed, 10 Aug 2016 03:51:34 GMT
    >>> vary: accept-encoding
    >>>
    >>> { "signature"   : "..."
    >>> , "payload"     : { "adFree" : { "fee"      : { "USD" : 5 }
    >>>                                , "altcurrency" : "BAT"
    >>>                                , "probi"       : 845480
    >>>                                , "votes"       : 5
    >>>                                }
    >>>                   }
    >>> , "surveyorId"  : "9czn9x3e26WGmmC09FapUmret1fjupI1lGC6Q7g0H9b"
    >>> , "surveyVK"    : "..."
    >>> , "registrarVK" : "..."
    >>> }

The contribution amount is found in the contribution surveyor's `payload` -- this information is _advisory_.

On success,
the client makes the `GET /v2/wallet/{paymentId}` request to see if the its wallet has sufficient funds,
and,
if so, to receive an unsigned transaction to effect funds transfer from the wallet to a settlement account:

    <<< GET /v2/wallet/e43bc29a-7048-486c-b75b-6c4970b4ce2a?refresh=true&amount=5&currency=USD
    <<< content-type: application/json; charset=utf-8
    <<< accept-encoding:
    <<<
    >>> HTTP/1.1 200
    >>> cache-control: no-cache
    >>> content-type: application/json; charset=utf-8
    >>> date: Wed, 10 Aug 2016 03:51:35 GMT
    >>> vary: accept-encoding
    >>>
    >>> { "paymentStamp" : 0
    >>> , "rates"        : { "USD" : 591.43 }
    >>> , "balance"      : "0.0335"
    >>> , "altcurrency"  : "BAT"
    >>> , "probi"        : 3350000
    >>> , "buyURL"       : "https://uphold.com?..."
    >>> , "unsignedTx"   : 
    >>>   { "denomination" : { "amount": "10", currency: "BAT" }
    >>>   , "destination"  : address
    >>>   }
    >>> }

The client periodically checks to see when its wallet is sufficiently funded.
Instead of using the `GET /v2/wallet/{paymentId}` request,
the client may primarily use a pool of third-party blockchain reporters in order to minimize load the on the ledger 
servers.

Once the client determines that its wallet has sufficient funds,
the client signs the trasnsaction and makes the `PUT /v2/wallet/{paymentId}` request to have the appropriate amount transfered
to the settlement account with this payload:

    <<< PUT /v2/wallet/e43bc29a-7048-486c-b75b-6c4970b4ce2a
    <<< content-type: application/json; charset=utf-8
    <<< surveyorId: "9czn9x3e26WGmmC09FapUmret1fjupI1lGC6Q7g0H9b"
    <<< viewingId: "f2be4fac-b9de-49b3-95a4-4902a2d5f1d7"
    <<< Signature: keyId="<paymentId>",algorithm="ed25519",
    <<< headers="digest content-length",
    <<< signature="Base64(ed25519-SHA256(signing string))"
    <<< digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=\n
    <<< accept-encoding:
    >>>
    >>> { "denomination" : { "amount": "10", currency: "BAT" }
    >>> , "destination"  : address
    >>> }
    >>> HTTP/1.1 200
    >>> cache-control: no-cache
    >>> content-type: application/json; charset=utf-8
    >>> date: Wed, 10 Aug 2016 03:51:35 GMT
    >>> vary: accept-encoding
    >>>
    >>> { "paymentStamp" : 1470801109946
    >>> , "probi"        : 845480
    >>> , "altcurrency"  : "BAT"
    >>> , "votes"        : 5
    >>> , "hash"         : '...'
    >>> }

During the processing of the request,
the ledger fowards the signed transaction to uphold.
If the transaction is accepted by uphold,
then a `200` response is returned with an updated `paymentStamp` property,
the number of `probi` transferred,
and the corresponding number of `votes` that are authorized for the `viewingId`;
otherwise,
the appropriate `4xx` or `5xx` response is returned.

On success,
the client updates `reconcileStamp` and adds a new object to the `transactions` array:

    { "viewingId"    : "f2be4fac-b9de-49b3-95a4-4902a2d5f1d7"
    , "surveyorId"   : "9czn9x3e26WGmmC09FapUmret1fjupI1lGC6Q7g0H9b"
    , "fee"          :
      { "currency"   : "USD"
      , "amount"     : 5
      }
    , "paymentStamp" : 1470801109946
    , "altcurrency"  : "BAT"
    , "probi"        : 845480
    , "vote"         : 5
    }

The client creates a credential for the `viewingId` making the `GET /v2/registrar/viewing` request:

    <<< GET /v2/registrar/viewing
    <<< content-type: application/json; charset=utf-8
    <<< accept-encoding:
    <<<
    >>> HTTP/1.1 200
    >>> cache-control: no-cache
    >>> content-type: application/json; charset=utf-8
    >>> date: Wed, 10 Aug 2016 04:15:49 GMT
    >>> vary: accept-encoding
    >>>
    >>> { "registrarVK" : "..." }

Following this is the `POST /v2/registrar/viewing/{userId}` request:

    <<< POST /v2/registrar/viewing/f2be4facb9de9b395a44902a2d5f1d7
    <<< content-type: application/json; charset=utf-8
    <<< accept-encoding:
    <<<
    <<< { "proof" : "..." }
    >>> HTTP/1.1 200
    >>> cache-control: no-cache
    >>> content-type: application/json; charset=utf-8
    >>> date: Wed, 10 Aug 2016 04:15:50 GMT
    >>> vary: accept-encoding
    >>>
    >>> { "surveyorIds"  :
    >>>   [ "87++H/BlRoy1t12WzZ2bNkbNy4RFpkrpb5Dn29Rhd2h"
    >>>   , "Cj+w4lEuKU3L0OzrLnhV93WLifEHMhrkrqNevYOW+D9"
    >>>   , "75GqrjsWUIv48soMhiiPmyW48Jtn47ffL04o+E6xjAX"
    >>>   , "D7EKCnXzVJrnnAIct5a9Y8ev8UdhElqlzKQTfZ/ciYb"
    >>>   , "AiGqEJ+b4LEa/7kyFjBvLt4OuQXuCPnYH048mhnr3qD"
    >>>   ]
    >>> , "verification" : "..."
    >>> }

On success,
the ledger returns a `surveyorIds` parameter identifying each of the voting surveyors that the `viewingId` is authorized
to use.
After the client verifies the registrar's signature,
the client extends the corresponding object in the `transaction` array with these properties:

    { "credential"  : "{\"userId\":\"f2be4facb9de9b395a44902a2d5f1d7\",...}"
    , "surveyorIds" :
      [ "87++H/BlRoy1t12WzZ2bNkbNy4RFpkrpb5Dn29Rhd2h"
      , "Cj+w4lEuKU3L0OzrLnhV93WLifEHMhrkrqNevYOW+D9"
      , "75GqrjsWUIv48soMhiiPmyW48Jtn47ffL04o+E6xjAX"
      , "D7EKCnXzVJrnnAIct5a9Y8ev8UdhElqlzKQTfZ/ciYb"
      , "AiGqEJ+b4LEa/7kyFjBvLt4OuQXuCPnYH048mhnr3qD"
      ]
    , "count"       : 0
    }

For each entry in the `surveyorIds` array,
the client adds an entry to the `ballots` array, e.g.:

    { "viewingId"  : "f2be4fac-b9de-49b3-95a4-4902a2d5f1d7"
    , "surveyorId" : "87++H/BlRoy1t12WzZ2bNkbNy4RFpkrpb5Dn29Rhd2h"
    , "publisher"  : "wikipedia.org"
    }

The `viewingId` property is taken from the corresponding entry in the `transactions` array,
the `surveyorId` property is taken from the `surveyorIds` array,
and the `publisher` property is chosen unpredictably
(based on the relative percentage that the user has viewed the publisher's site).
As each entry is added to the `ballots` array,
the `count` property in the corresponding entry in the `transactions` array is incremented.

For each new entry in the `ballots` array,
the client makes the `GET /v2/surveyor/voting/{surveyorId}/{viewingId}` request to get information about the voting surveyor
to be used for this ballot:

    <<< GET /v2/surveyor/voting/87%2B%2BH%2FBlRoy1t12WzZ2bNkbNy4RFpkrpb5Dn29Rhd2h/f2be4facb9de9b395a44902a2d5f1d7
    <<< content-type: application/json; charset=utf-8
    <<< accept-encoding:
    <<<
    >>> HTTP/1.1 200
    >>> cache-control: no-cache
    >>> content-type: application/json; charset=utf-8
    >>> date: Wed, 10 Aug 2016 04:17:04 GMT
    >>> vary: accept-encoding
    >>>
    >>> { "signature"   : "..."
    >>> , "payload"     : {}
    >>> , "surveyorId"  : "87++H/BlRoy1t12WzZ2bNkbNy4RFpkrpb5Dn29Rhd2h"
    >>> , "surveyVK"    : "..."
    >>> , "registrarVK" : "..."
    >>> }

This information is then placed into a `prepareBallot` object and added to the corresponding entry in the `ballots` array:

      { "signature"   : "..."
      , "payload"     : {}
      , "surveyorId"  : "87++H/BlRoy1t12WzZ2bNkbNy4RFpkrpb5Dn29Rhd2h"
      , "surveyVK"    : "..."
      , "registrarVK" : "..."
      , "server"      :
        { "protocol"  : "https:"
        , ...
        , "href"      : "https://ledger.brave.com/"
        }
      }

The client delays an unpredictable amount of time (e.g., typically within a three-hour period),
and then makes the `PUT /v2/surveyor/voting/{surveyorId}` request with a `payload` parameter
containing the `publisher` receiving the vote for the associated contribution surveyor:

    <<< PUT /v2/surveyor/voting/87%2B%2BH%2FBlRoy1t12WzZ2bNkbNy4RFpkrpb5Dn29Rhd2h
    <<< content-type: application/json; charset=utf-8
    <<< accept-encoding:
    <<<
    <<< { "proof" : "{\"publisher\":\"wikipedia.org\"}\n..." }
    >>> HTTP/1.1 200
    >>> cache-control: no-cache
    >>> content-type: application/json; charset=utf-8
    >>> date: Wed, 10 Aug 2016 04:57:02 GMT
    >>> vary: accept-encoding
    >>>
    >>> { "submissionId" : "..." }

### How Contributions are Processed
__to be filled-in in the next draft__

## Operational Security

### Correlating Surveyor Operations
When the client performs the `GET /v2/surveyor/{surveyorType}/{surveyorId}/{uID}` operation,
it necessarily identifies itself to the surveyor in order to receive a secret that authorizes it to anonymously perform the 
`PUT /v2/surveyor/{surveyortype}/{surveyorId}` operation.

However,
there are two ways that Brave Software or a third-party observer can correlate the operations:
timing and IP addresses.

To avoid correlation via timing,
the steps above indicate when an unpredictable delay should be interposed by the client when performing the operations.

To avoid corrleation via IP address,
the client uses an IP address obfuscation technology to blind the IP address.

### Client Wallets
A client wallet is an anonymous BAT card with uphold.
These require ECC signatures in order to perform funds transfer.
Independently, the uphold service requires an API key from Brave Software in order to process requests.

Brave Software has the ability to check the balance independently from the client,
but not make withdrawals.
In order to make a withdrawal,
the client receives an unsigned transaction in response to the `GET /v2/wallet/{paymentId}` request,
and then submits the signed transaction in the payload to the `PUT /v2/wallet/{paymentId}` request.

A client wallet is limited as to its 30-day velocity.

If a client loses the key, the user employs the recovery file to recover it.

### Brave Settlement Wallets
These wallets are "locked-down" to permit transfers only to other Brave wallets.
In turn,
these wallets,
that are rotated frequently, are used to transfer into publisher and persona wallets.

When created,
settlement wallets have their backup key sent to a KRS.

## Acknowledgements
Many helpful comments have dramatically increased the simplicity, readability and correctness of this specification.
In particular,
the comments of [Alex Melville](https://github.com/Melvillian) of [BitGo](https://www.bitgo.com) have been particularly helpful.
